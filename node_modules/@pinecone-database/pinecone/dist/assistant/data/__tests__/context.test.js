"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const context_1 = require("../context");
const assistant_data_1 = require("../../../pinecone-generated-ts-fetch/assistant_data");
const setupApiProvider = () => {
    const fakeContextAssistant = jest
        .fn()
        .mockImplementation(() => Promise.resolve({}));
    const MAP = {
        contextAssistant: fakeContextAssistant,
    };
    const AsstDataOperationsProvider = {
        provideData: async () => MAP,
    };
    return { MAP, AsstDataOperationsProvider };
};
describe('contextClosed', () => {
    let mockApi;
    let asstOperationsProvider;
    beforeEach(() => {
        const { MAP, AsstDataOperationsProvider } = setupApiProvider();
        mockApi = MAP;
        asstOperationsProvider = AsstDataOperationsProvider;
    });
    test('creates a context function that calls the API with correct parameters', async () => {
        const assistantName = 'test-assistant';
        const contextFn = (0, context_1.context)(assistantName, asstOperationsProvider);
        const options = {
            query: 'test query',
            filter: { key: 'value' },
        };
        await contextFn(options);
        expect(mockApi.contextAssistant).toHaveBeenCalledWith({
            assistantName,
            contextRequest: {
                query: options.query,
                filter: options.filter,
                messages: undefined,
                topK: undefined,
                snippetSize: undefined,
                multimodal: undefined,
                includeBinaryContent: undefined,
            },
            xPineconeApiVersion: assistant_data_1.X_PINECONE_API_VERSION,
        });
    });
    test('passes multimodal parameters correctly', async () => {
        const assistantName = 'test-assistant';
        const contextFn = (0, context_1.context)(assistantName, asstOperationsProvider);
        const options = {
            query: 'test query',
            multimodal: true,
            includeBinaryContent: true,
        };
        await contextFn(options);
        expect(mockApi.contextAssistant).toHaveBeenCalledWith({
            assistantName,
            contextRequest: {
                query: options.query,
                filter: undefined,
                messages: undefined,
                topK: undefined,
                snippetSize: undefined,
                multimodal: true,
                includeBinaryContent: true,
            },
            xPineconeApiVersion: assistant_data_1.X_PINECONE_API_VERSION,
        });
    });
    test('passes multimodal false and includeBinaryContent false correctly', async () => {
        const assistantName = 'test-assistant';
        const contextFn = (0, context_1.context)(assistantName, asstOperationsProvider);
        const options = {
            query: 'test query',
            multimodal: false,
            includeBinaryContent: false,
        };
        await contextFn(options);
        expect(mockApi.contextAssistant).toHaveBeenCalledWith({
            assistantName,
            contextRequest: {
                query: options.query,
                filter: undefined,
                messages: undefined,
                topK: undefined,
                snippetSize: undefined,
                multimodal: false,
                includeBinaryContent: false,
            },
            xPineconeApiVersion: assistant_data_1.X_PINECONE_API_VERSION,
        });
    });
    test('throws error when query is empty', async () => {
        const contextFn = (0, context_1.context)('test-assistant', asstOperationsProvider);
        await expect(contextFn({ query: '' })).rejects.toThrow('You must pass an object with required properties (`query`, or `messages`) to retrieve context snippets.');
    });
    test('works without filter parameter', async () => {
        const assistantName = 'test-assistant';
        const contextFn = (0, context_1.context)(assistantName, asstOperationsProvider);
        const options = {
            query: 'test query',
        };
        await contextFn(options);
        expect(mockApi.contextAssistant).toHaveBeenCalledWith({
            assistantName,
            contextRequest: {
                query: options.query,
                filter: undefined,
                messages: undefined,
                topK: undefined,
                snippetSize: undefined,
                multimodal: undefined,
                includeBinaryContent: undefined,
            },
            xPineconeApiVersion: assistant_data_1.X_PINECONE_API_VERSION,
        });
    });
    test('passes all optional parameters correctly', async () => {
        const assistantName = 'test-assistant';
        const contextFn = (0, context_1.context)(assistantName, asstOperationsProvider);
        const options = {
            query: 'test query',
            topK: 20,
            snippetSize: 1024,
            filter: { category: 'docs' },
            multimodal: true,
            includeBinaryContent: false,
        };
        await contextFn(options);
        expect(mockApi.contextAssistant).toHaveBeenCalledWith({
            assistantName,
            contextRequest: {
                query: options.query,
                filter: options.filter,
                messages: undefined,
                topK: 20,
                snippetSize: 1024,
                multimodal: true,
                includeBinaryContent: false,
            },
            xPineconeApiVersion: assistant_data_1.X_PINECONE_API_VERSION,
        });
    });
});
//# sourceMappingURL=context.test.js.map