"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FetchByMetadataCommand = void 0;
const db_data_1 = require("../../pinecone-generated-ts-fetch/db_data");
const errors_1 = require("../../errors");
class FetchByMetadataCommand {
    apiProvider;
    namespace;
    constructor(apiProvider, namespace) {
        this.apiProvider = apiProvider;
        this.namespace = namespace;
    }
    validator = (options) => {
        if (!options || !options.filter) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty object for the `filter` field in order to fetch by metadata.');
        }
    };
    async run(options) {
        this.validator(options);
        const namespace = options.namespace ?? this.namespace;
        const api = await this.apiProvider.provide();
        const request = {
            fetchByMetadataRequest: {
                namespace,
                filter: options.filter,
                limit: options.limit,
                paginationToken: options.paginationToken,
            },
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
        };
        const response = await api.fetchVectorsByMetadata(request);
        return {
            records: response.vectors ? response.vectors : {},
            namespace: response.namespace ? response.namespace : '',
            ...(response.usage && { usage: response.usage }),
            pagination: response.pagination ? response.pagination : undefined,
        };
    }
}
exports.FetchByMetadataCommand = FetchByMetadataCommand;
//# sourceMappingURL=fetchByMetadata.js.map