"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const db_data_1 = require("../../../pinecone-generated-ts-fetch/db_data");
const createNamespace_1 = require("../../namespaces/createNamespace");
const errors_1 = require("../../../errors");
const setupResponse = (response, isSuccess) => {
    const fakeCreateNamespace = jest
        .fn()
        .mockImplementation(() => isSuccess ? Promise.resolve(response) : Promise.reject(response));
    const NOA = {
        createNamespace: fakeCreateNamespace,
    };
    const NamespaceOperationsProvider = {
        provide: async () => NOA,
    };
    const cmd = (0, createNamespace_1.createNamespace)(NamespaceOperationsProvider);
    return { fakeCreateNamespace, NOA, NamespaceOperationsProvider, cmd };
};
describe('createNamespace', () => {
    test('should call createNamespace with correct request', async () => {
        const name = 'test-namespace';
        const schema = { fields: { testField: { filterable: true } } };
        const { cmd, fakeCreateNamespace } = setupResponse({
            name,
            schema,
        }, true);
        await cmd({ name, schema });
        expect(fakeCreateNamespace).toHaveBeenCalledWith({
            createNamespaceRequest: { name, schema },
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
        });
    });
    test('should throw PineconeArgumentError if name is not provided', async () => {
        const { cmd } = setupResponse(undefined, false);
        await expect(cmd({ name: '' })).rejects.toThrow(errors_1.PineconeArgumentError);
        await expect(cmd({ name: '' })).rejects.toThrow('You must pass a non-empty string for `name` in order to create a namespace.');
    });
});
//# sourceMappingURL=createNamespace.test.js.map