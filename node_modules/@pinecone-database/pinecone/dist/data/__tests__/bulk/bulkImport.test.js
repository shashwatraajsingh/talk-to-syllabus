"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const startImport_1 = require("../../bulk/startImport");
const listImports_1 = require("../../bulk/listImports");
const describeImport_1 = require("../../bulk/describeImport");
const cancelImport_1 = require("../../bulk/cancelImport");
const db_data_1 = require("../../../pinecone-generated-ts-fetch/db_data");
const errors_1 = require("../../../errors");
const setupResponse = (response, isSuccess) => {
    const fakeStartImport = jest
        .fn()
        .mockImplementation(() => isSuccess ? Promise.resolve(response) : Promise.reject(response));
    const fakeListImports = jest
        .fn()
        .mockImplementation(() => isSuccess ? Promise.resolve(response) : Promise.reject(response));
    const fakeDescribeImport = jest
        .fn()
        .mockImplementation(() => isSuccess ? Promise.resolve(response) : Promise.reject(response));
    const fakeCancelImport = jest
        .fn()
        .mockImplementation(() => isSuccess ? Promise.resolve(response) : Promise.reject(response));
    const BOA = {
        startBulkImport: fakeStartImport,
        listBulkImports: fakeListImports,
        describeBulkImport: fakeDescribeImport,
        cancelBulkImport: fakeCancelImport,
    };
    const BulkOperationsProvider = {
        provide: async () => BOA,
    };
    const startCmd = new startImport_1.StartImportCommand(BulkOperationsProvider);
    const listCmd = new listImports_1.ListImportsCommand(BulkOperationsProvider);
    const describeCmd = new describeImport_1.DescribeImportCommand(BulkOperationsProvider);
    const cancelCmd = new cancelImport_1.CancelImportCommand(BulkOperationsProvider);
    return {
        fakeStartImport,
        fakeListImports,
        fakeDescribeImport,
        fakeCancelImport,
        BOA,
        BulkOperationsProvider,
        startCmd,
        listCmd,
        describeCmd,
        cancelCmd,
    };
};
describe('StartImportCommand', () => {
    test('should call startImport with correct request when errorMode is "continue"', async () => {
        const { startCmd, fakeStartImport } = setupResponse({ id: '1' }, true);
        const uri = 's3://my-bucket/my-file.csv';
        const errorMode = 'continue';
        await startCmd.run({ uri, errorMode });
        expect(fakeStartImport).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            startImportRequest: {
                uri,
                errorMode: { onError: 'continue' },
            },
        }));
    });
    test('should call startImport with correct request when errorMode is "abort"', async () => {
        const { startCmd, fakeStartImport } = setupResponse({ id: '1' }, true);
        const uri = 's3://my-bucket/my-file.csv';
        const errorMode = 'abort';
        await startCmd.run({ uri, errorMode });
        expect(fakeStartImport).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            startImportRequest: {
                uri,
                errorMode: { onError: 'abort' },
            },
        }));
    });
    test('should throw PineconeArgumentError for invalid errorMode', async () => {
        const { startCmd } = setupResponse({ id: '1' }, false);
        const uri = 's3://my-bucket/my-file.csv';
        const errorMode = 'invalid';
        // @ts-expect-error - invalid errorMode
        await expect(startCmd.run({ uri, errorMode })).rejects.toThrow(errors_1.PineconeArgumentError);
    });
    test('should use "continue" as default when errorMode is undefined', async () => {
        const { startCmd, fakeStartImport } = setupResponse({ id: '1' }, true);
        const uri = 's3://my-bucket/my-file.csv';
        await startCmd.run({ uri });
        expect(fakeStartImport).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            startImportRequest: {
                uri,
                errorMode: { onError: 'continue' },
            },
        }));
    });
    test('should throw error when URI/1st arg is missing', async () => {
        const { startCmd } = setupResponse(undefined, false);
        // @ts-expect-error - invalid URI
        await expect(startCmd.run({})).rejects.toThrow(errors_1.PineconeArgumentError);
        // @ts-expect-error - invalid URI
        await expect(startCmd.run({})).rejects.toThrow('`uri` field is required and must start with the scheme of a supported storage provider.');
    });
    test('should call listImport with correct request', async () => {
        const { listCmd, fakeListImports } = setupResponse({ imports: [] }, true);
        const limit = 1;
        await listCmd.run(limit);
        expect(fakeListImports).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            limit,
        }));
    });
    test('should call describeImport with correct request', async () => {
        const { describeCmd, fakeDescribeImport } = setupResponse({ id: '1' }, true);
        const importId = 'import-id';
        await describeCmd.run(importId);
        expect(fakeDescribeImport).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            id: importId,
        }));
    });
    test('should call cancelImport with correct request', async () => {
        const { cancelCmd, fakeCancelImport } = setupResponse({ id: '1' }, true);
        const importId = 'import-id';
        await cancelCmd.run(importId);
        expect(fakeCancelImport).toHaveBeenCalledWith(expect.objectContaining({
            xPineconeApiVersion: db_data_1.X_PINECONE_API_VERSION,
            id: importId,
        }));
    });
});
//# sourceMappingURL=bulkImport.test.js.map