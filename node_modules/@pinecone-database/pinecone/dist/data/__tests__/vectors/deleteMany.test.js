"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deleteMany_1 = require("../../vectors/deleteMany");
const deleteOne_test_1 = require("./deleteOne.test");
const errors_1 = require("../../../errors");
const api_version_1 = require("../../../pinecone-generated-ts-fetch/db_data/api_version");
describe('deleteMany', () => {
    test('calls the openapi delete endpoint, passing ids with target namespace', async () => {
        const { VectorProvider, VOA } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const returned = await deleteManyFn({ ids: ['123', '456', '789'] });
        expect(returned).toBe(void 0);
        expect(VOA.deleteVectors).toHaveBeenCalledWith({
            deleteRequest: { ids: ['123', '456', '789'], namespace: 'namespace' },
            xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
        });
    });
    test('calls the openapi delete endpoint, passing filter with target namespace', async () => {
        const { VOA, VectorProvider } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const returned = await deleteManyFn({ filter: { genre: 'ambient' } });
        expect(returned).toBe(void 0);
        expect(VOA.deleteVectors).toHaveBeenCalledWith({
            deleteRequest: { filter: { genre: 'ambient' }, namespace: 'namespace' },
            xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
        });
    });
    test('throws if pass in empty filter obj', async () => {
        const { VectorProvider } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const toThrow = async () => {
            await deleteManyFn({ filter: { some: '' } });
        };
        await expect(toThrow()).rejects.toThrowError(errors_1.PineconeArgumentError);
        await expect(toThrow()).rejects.toThrowError('`filter` property cannot be empty');
    });
    test('throws if pass no record IDs', async () => {
        const { VectorProvider } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const toThrow = async () => {
            await deleteManyFn({ ids: [] });
        };
        await expect(toThrow()).rejects.toThrowError(errors_1.PineconeArgumentError);
        await expect(toThrow()).rejects.toThrowError('Must pass in at least 1 record ID.');
    });
    test('throws if both ids and filter are provided', async () => {
        const { VectorProvider } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const toThrow = async () => {
            await deleteManyFn({ ids: ['123'], filter: { genre: 'ambient' } });
        };
        await expect(toThrow()).rejects.toThrowError(errors_1.PineconeArgumentError);
        await expect(toThrow()).rejects.toThrowError('Cannot provide both `ids` and `filter`');
    });
    test('throws if neither ids nor filter are provided', async () => {
        const { VectorProvider } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        const toThrow = async () => {
            await deleteManyFn({});
        };
        await expect(toThrow()).rejects.toThrowError(errors_1.PineconeArgumentError);
        await expect(toThrow()).rejects.toThrowError('Either `ids` or `filter` must be provided');
    });
    test('uses namespace from options when provided with ids', async () => {
        const { VectorProvider, VOA } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        await deleteManyFn({ ids: ['123', '456'], namespace: 'custom-namespace' });
        expect(VOA.deleteVectors).toHaveBeenCalledWith({
            deleteRequest: { ids: ['123', '456'], namespace: 'custom-namespace' },
            xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
        });
    });
    test('uses namespace from options when provided with filter', async () => {
        const { VectorProvider, VOA } = (0, deleteOne_test_1.setupDeleteSuccess)(undefined);
        const deleteManyFn = (0, deleteMany_1.deleteMany)(VectorProvider, 'namespace');
        await deleteManyFn({
            filter: { genre: 'ambient' },
            namespace: 'custom-namespace',
        });
        expect(VOA.deleteVectors).toHaveBeenCalledWith({
            deleteRequest: {
                filter: { genre: 'ambient' },
                namespace: 'custom-namespace',
            },
            xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
        });
    });
});
//# sourceMappingURL=deleteMany.test.js.map