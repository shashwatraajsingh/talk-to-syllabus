"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureIndex = void 0;
const db_control_1 = require("../pinecone-generated-ts-fetch/db_control");
const errors_1 = require("../errors");
const createIndex_1 = require("./createIndex");
const configureIndex = (api) => {
    const validator = (options) => {
        if (!options.name) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` to configureIndex.');
        }
        // !options.deletionProtection evaluates to false if options.deletionProtection is undefined, empty string, or
        // not provided
        if (!options.deletionProtection &&
            !options.tags &&
            !options.embed &&
            options.podReplicas === undefined &&
            options.podType === undefined &&
            options.readCapacity === undefined) {
            throw new errors_1.PineconeArgumentError('You must pass at least one configuration option to configureIndex.');
        }
        if (options.readCapacity) {
            (0, createIndex_1.validateReadCapacity)(options.readCapacity);
        }
    };
    return async (options) => {
        validator(options);
        const spec = buildConfigureSpec(options);
        const request = {
            deletionProtection: options.deletionProtection,
            tags: options.tags,
            embed: options.embed,
            spec,
        };
        return await api.configureIndex({
            xPineconeApiVersion: db_control_1.X_PINECONE_API_VERSION,
            indexName: options.name,
            configureIndexRequest: request,
        });
    };
};
exports.configureIndex = configureIndex;
const buildConfigureSpec = (options) => {
    const hasPod = options.podReplicas !== undefined || options.podType !== undefined;
    const hasServerless = options.readCapacity !== undefined;
    if (hasPod && hasServerless) {
        throw new errors_1.PineconeArgumentError('Cannot configure both serverless (readCapacity) and pod (podReplicas/podType)index values.');
    }
    if (hasPod) {
        return {
            pod: {
                replicas: options.podReplicas,
                podType: options.podType,
            },
        };
    }
    if (hasServerless) {
        return {
            serverless: {
                readCapacity: (0, createIndex_1.toApiReadCapacity)(options.readCapacity),
            },
        };
    }
    return undefined;
};
//# sourceMappingURL=configureIndex.js.map