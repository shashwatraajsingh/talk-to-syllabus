"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createIndexForModel_1 = require("../createIndexForModel");
const errors_1 = require("../../errors");
const api_version_1 = require("../../pinecone-generated-ts-fetch/db_control/api_version");
// describeIndexResponse can either be a single response, or an array of responses for testing polling scenarios
const setupCreateIndexForModelResponse = (createIndexForModelResponse, describeIndexResponse, isCreateIndexSuccess = true, isDescribeIndexSuccess = true) => {
    const fakeCreateIndexForModel = jest
        .fn()
        .mockImplementation(() => isCreateIndexSuccess
        ? Promise.resolve(createIndexForModelResponse)
        : Promise.reject(createIndexForModelResponse));
    // unfold describeIndexResponse
    const describeIndexResponses = Array.isArray(describeIndexResponse)
        ? describeIndexResponse
        : [describeIndexResponse];
    const describeIndexMock = jest.fn();
    describeIndexResponses.forEach((response) => {
        describeIndexMock.mockImplementationOnce(() => isDescribeIndexSuccess
            ? Promise.resolve(response)
            : Promise.reject({ response }));
    });
    const fakeDescribeIndex = describeIndexMock;
    const MIA = {
        createIndexForModel: fakeCreateIndexForModel,
        describeIndex: fakeDescribeIndex,
    };
    return MIA;
};
describe('createIndexForModel', () => {
    test('calls the openapi create index for model endpoint', async () => {
        const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, {
            status: { ready: true, state: 'Ready' },
        });
        const mockCreateReq = {
            name: 'test-index',
            cloud: 'aws',
            region: 'us-east-1',
            embed: {
                model: 'test-model',
                metric: 'cosine',
                fieldMap: { testField: 'test-field' },
                readParameters: { testReadParam: 'test-read-param' },
                writeParameters: { testWriteParam: 'test-write-param' },
            },
            deletionProtection: 'enabled',
            tags: { testTag: 'test-tag' },
        };
        await (0, createIndexForModel_1.createIndexForModel)(MIA)(mockCreateReq);
        expect(MIA.createIndexForModel).toHaveBeenCalledWith({
            createIndexForModelRequest: mockCreateReq,
            xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
        });
    });
    test('throws error if no name is passed', async () => {
        const MIA = setupCreateIndexForModelResponse(undefined, undefined);
        try {
            // @ts-ignore
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                cloud: 'aws',
                region: 'us-east-1',
                embed: {
                    model: 'test-model',
                    fieldMap: { testField: 'test-field' },
                },
            });
        }
        catch (err) {
            expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
            expect(err.message).toBe('You must pass a non-empty string for `name` in order to create an index.');
        }
    });
    test('throws error if no cloud is passed', async () => {
        const MIA = setupCreateIndexForModelResponse(undefined, undefined);
        try {
            // @ts-ignore
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                region: 'us-east-1',
                embed: {
                    model: 'test-model',
                    fieldMap: { testField: 'test-field' },
                },
            });
        }
        catch (err) {
            expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
            expect(err.message).toBe('You must pass a non-empty string for `cloud` in order to create an index.');
        }
    });
    test('throws error if no region is passed', async () => {
        const MIA = setupCreateIndexForModelResponse(undefined, undefined);
        try {
            // @ts-ignore
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'aws',
                embed: {
                    model: 'test-model',
                    fieldMap: { testField: 'test-field' },
                },
            });
        }
        catch (err) {
            expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
            expect(err.message).toBe('You must pass a non-empty string for `region` in order to create an index.');
        }
    });
    test('throws error if no embed object is passed', async () => {
        const MIA = setupCreateIndexForModelResponse(undefined, undefined);
        try {
            // @ts-ignore
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'aws',
                region: 'us-east-1',
            });
        }
        catch (err) {
            expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
            expect(err.message).toBe('You must pass an `embed` object in order to create an index.');
        }
    });
    describe('createIndexForModel with readCapacity', () => {
        test('creates index with default OnDemand readCapacity when omitted', async () => {
            const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, { status: { ready: true, state: 'Ready' } });
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'aws',
                region: 'us-east-1',
                embed: {
                    model: 'multilingual-e5-large',
                    fieldMap: { text: 'text' },
                },
            });
            expect(MIA.createIndexForModel).toHaveBeenCalledWith({
                createIndexForModelRequest: {
                    name: 'test-index',
                    cloud: 'aws',
                    region: 'us-east-1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    readCapacity: undefined,
                },
                xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
            });
        });
        test('creates index with explicit OnDemand readCapacity', async () => {
            const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, { status: { ready: true, state: 'Ready' } });
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'aws',
                region: 'us-east-1',
                embed: {
                    model: 'multilingual-e5-large',
                    fieldMap: { text: 'text' },
                },
                readCapacity: { mode: 'OnDemand' },
            });
            expect(MIA.createIndexForModel).toHaveBeenCalledWith({
                createIndexForModelRequest: {
                    name: 'test-index',
                    cloud: 'aws',
                    region: 'us-east-1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    readCapacity: { mode: 'OnDemand' },
                },
                xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
            });
        });
        test('creates index with Dedicated readCapacity', async () => {
            const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, { status: { ready: true, state: 'Ready' } });
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'gcp',
                region: 'us-central1',
                embed: {
                    model: 'multilingual-e5-large',
                    fieldMap: { text: 'text' },
                },
                readCapacity: {
                    mode: 'Dedicated',
                    nodeType: 't1',
                    manual: { replicas: 3, shards: 2 },
                },
            });
            expect(MIA.createIndexForModel).toHaveBeenCalledWith({
                createIndexForModelRequest: {
                    name: 'test-index',
                    cloud: 'gcp',
                    region: 'us-central1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    readCapacity: {
                        mode: 'Dedicated',
                        dedicated: {
                            nodeType: 't1',
                            scaling: 'Manual',
                            manual: { replicas: 3, shards: 2 },
                        },
                    },
                },
                xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
            });
        });
        test('creates index with Dedicated readCapacity (mode inferred)', async () => {
            const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, { status: { ready: true, state: 'Ready' } });
            await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'azure',
                region: 'eastus2',
                embed: {
                    model: 'multilingual-e5-large',
                    fieldMap: { text: 'text' },
                },
                readCapacity: {
                    nodeType: 'b1',
                    manual: { replicas: 1, shards: 1 },
                },
            });
            expect(MIA.createIndexForModel).toHaveBeenCalledWith({
                createIndexForModelRequest: {
                    name: 'test-index',
                    cloud: 'azure',
                    region: 'eastus2',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    readCapacity: {
                        mode: 'Dedicated',
                        dedicated: {
                            nodeType: 'b1',
                            scaling: 'Manual',
                            manual: { replicas: 1, shards: 1 },
                        },
                    },
                },
                xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
            });
        });
    });
    describe('createIndexForModel readCapacity validation', () => {
        test('throws error for invalid readCapacity mode', async () => {
            const MIA = setupCreateIndexForModelResponse(undefined, undefined);
            try {
                await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                    name: 'test-index',
                    cloud: 'aws',
                    region: 'us-east-1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    // @ts-ignore
                    readCapacity: { mode: 'BadMode' },
                });
                fail('Should have thrown an error');
            }
            catch (err) {
                expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
                expect(err.message).toMatch(/Invalid read capacity mode/i);
            }
        });
        test('throws error for invalid dedicated nodeType', async () => {
            const MIA = setupCreateIndexForModelResponse(undefined, undefined);
            try {
                await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                    name: 'test-index',
                    cloud: 'aws',
                    region: 'us-east-1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    readCapacity: {
                        // @ts-ignore
                        nodeType: 'x99',
                        manual: { replicas: 1, shards: 1 },
                    },
                });
                fail('Should have thrown an error');
            }
            catch (err) {
                expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
                expect(err.message).toMatch(/Invalid node type.*b1.*t1/i);
            }
        });
        test('throws error for missing manual config', async () => {
            const MIA = setupCreateIndexForModelResponse(undefined, undefined);
            try {
                await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                    name: 'test-index',
                    cloud: 'aws',
                    region: 'us-east-1',
                    embed: {
                        model: 'multilingual-e5-large',
                        fieldMap: { text: 'text' },
                    },
                    // @ts-ignore
                    readCapacity: { nodeType: 'b1' },
                });
                fail('Should have thrown an error');
            }
            catch (err) {
                expect(err).toBeInstanceOf(errors_1.PineconeArgumentError);
                expect(err.message).toMatch(/manual is required for dedicated mode/i);
            }
        });
    });
    describe('createIndexForModel with waitUntilReady', () => {
        beforeEach(() => {
            jest.useFakeTimers();
        });
        afterEach(() => {
            jest.useRealTimers();
        });
        test('polls describeIndex when waitUntilReady is true', async () => {
            const MIA = setupCreateIndexForModelResponse({ name: 'test-index' }, { status: { ready: true, state: 'Ready' } });
            const returned = await (0, createIndexForModel_1.createIndexForModel)(MIA)({
                name: 'test-index',
                cloud: 'aws',
                region: 'us-east-1',
                embed: {
                    model: 'multilingual-e5-large',
                    fieldMap: { text: 'text' },
                },
                waitUntilReady: true,
            });
            expect(returned).toEqual({ status: { ready: true, state: 'Ready' } });
            expect(MIA.describeIndex).toHaveBeenCalledWith({
                indexName: 'test-index',
                xPineconeApiVersion: api_version_1.X_PINECONE_API_VERSION,
            });
        });
    });
});
//# sourceMappingURL=createIndexForModel.test.js.map