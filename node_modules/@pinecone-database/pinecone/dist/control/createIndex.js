"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toApiReadCapacity = exports.isDedicated = exports.validateReadCapacity = exports.waitUntilIndexIsReady = exports.createIndex = void 0;
const db_control_1 = require("../pinecone-generated-ts-fetch/db_control");
const utils_1 = require("../utils");
const types_1 = require("./types");
const errors_1 = require("../errors");
const createIndex = (api) => {
    return async (options) => {
        if (!options) {
            throw new errors_1.PineconeArgumentError('You must pass an object with required properties (`name`, `dimension`, `spec`) to create an index.');
        }
        // If metric is not specified for a sparse index, default to dotproduct
        if (options.vectorType && options.vectorType.toLowerCase() === 'sparse') {
            if (!options.metric) {
                options.metric = 'dotproduct';
            }
        }
        else {
            // If metric is not specified for a dense index, default to cosine
            if (!options.metric) {
                options.metric = 'cosine';
            }
        }
        validateCreateIndexRequest(options);
        try {
            const createRequest = {
                ...options,
                spec: {
                    ...options.spec,
                    serverless: options.spec.serverless
                        ? {
                            ...options.spec.serverless,
                            readCapacity: (0, exports.toApiReadCapacity)(options.spec.serverless?.readCapacity),
                        }
                        : undefined,
                },
            };
            const createResponse = await api.createIndex({
                createIndexRequest: createRequest,
                xPineconeApiVersion: db_control_1.X_PINECONE_API_VERSION,
            });
            if (options.waitUntilReady) {
                return await (0, exports.waitUntilIndexIsReady)(api, options.name);
            }
            return createResponse;
        }
        catch (e) {
            if (!(options.suppressConflicts &&
                e instanceof Error &&
                e.name === 'PineconeConflictError')) {
                throw e;
            }
        }
    };
};
exports.createIndex = createIndex;
const waitUntilIndexIsReady = async (api, indexName, seconds = 0) => {
    try {
        const indexDescription = await api.describeIndex({
            indexName,
            xPineconeApiVersion: db_control_1.X_PINECONE_API_VERSION,
        });
        if (!indexDescription.status?.ready) {
            await new Promise((r) => setTimeout(r, 1000));
            return await (0, exports.waitUntilIndexIsReady)(api, indexName, seconds + 1);
        }
        else {
            (0, utils_1.debugLog)(`Index ${indexName} is ready after ${seconds}`);
            return indexDescription;
        }
    }
    catch (e) {
        const err = await (0, errors_1.handleApiError)(e, async (_, rawMessageText) => `Error creating index ${indexName}: ${rawMessageText}`);
        throw err;
    }
};
exports.waitUntilIndexIsReady = waitUntilIndexIsReady;
const validateCreateIndexRequest = (options) => {
    // validate options properties
    if (!options.name) {
        throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` in order to create an index.');
    }
    if (options.dimension && options.dimension <= 0) {
        throw new errors_1.PineconeArgumentError('You must pass a positive integer for `dimension` in order to create an index.');
    }
    // validate options.spec properties
    if (!options.spec) {
        throw new errors_1.PineconeArgumentError('You must pass a `pods`, `serverless`, or `byoc` `spec` object in order to create an index.');
    }
    // validate options.metric
    if (options.metric &&
        !['cosine', 'euclidean', 'dotproduct'].includes(options.metric.toLowerCase())) {
        {
            throw new errors_1.PineconeArgumentError(`Invalid metric value: ${options.metric}. Valid values are: 'cosine', 'euclidean', or 'dotproduct.'`);
        }
    }
    // validate options.spec.serverless properties if serverless spec is passed
    if (options.spec.serverless) {
        // extract and default vectorType to 'dense' if not specified
        const vectorType = options.vectorType
            ? options.vectorType.toLowerCase()
            : 'dense';
        if (vectorType !== 'dense' && vectorType !== 'sparse') {
            throw new errors_1.PineconeArgumentError('Invalid `vectorType` value. Valid values are `dense` or `sparse`.');
        }
        // sparse indexes must have a metric of 'dotproduct' and no dimension
        if (vectorType == 'sparse') {
            if (options.dimension && options.dimension > 0) {
                throw new errors_1.PineconeArgumentError('Sparse indexes cannot have a `dimension`.');
            }
            if (options.metric && options.metric !== 'dotproduct') {
                throw new errors_1.PineconeArgumentError('Sparse indexes must have a `metric` of `dotproduct`.');
            }
        }
        else if (vectorType == 'dense') {
            // dense indexes must have a dimension
            if (!options.dimension || options.dimension <= 0) {
                throw new errors_1.PineconeArgumentError('You must pass a positive `dimension` when creating a dense index.');
            }
        }
        // validate serverless cloud & region
        if (!options.spec.serverless.cloud) {
            throw new errors_1.PineconeArgumentError('You must pass a `cloud` for the serverless `spec` object in order to create an index.');
        }
        if (options.spec.serverless.cloud &&
            !['aws', 'gcp', 'azure'].includes(options.spec.serverless.cloud.toLowerCase())) {
            throw new errors_1.PineconeArgumentError(`Invalid cloud value: ${options.spec.serverless.cloud}. Valid values are: aws, gcp, or azure.`);
        }
        if (!options.spec.serverless.region) {
            throw new errors_1.PineconeArgumentError('You must pass a `region` for the serverless `spec` object in order to create an index.');
        }
        // validate readCapacity if provided
        if (options.spec.serverless.readCapacity) {
            (0, exports.validateReadCapacity)(options.spec.serverless.readCapacity);
        }
    }
    else if (options.spec.pod) {
        // validate options.spec.pod properties if pod spec is passed
        if (!options.spec.pod.environment) {
            throw new errors_1.PineconeArgumentError('You must pass an `environment` for the pod `spec` object in order to create an index.');
        }
        // pod indexes must have a dimension
        if (!options.dimension || options.dimension <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive `dimension` when creating a dense index.');
        }
        // pod indexes must be dense
        const vectorType = 'dense';
        if (options.vectorType && options.vectorType.toLowerCase() !== vectorType) {
            throw new errors_1.PineconeArgumentError('Pod indexes must have a `vectorType` of `dense`.');
        }
        if (!options.spec.pod.podType) {
            throw new errors_1.PineconeArgumentError('You must pass a `podType` for the pod `spec` object in order to create an index.');
        }
        if (options.spec.pod.replicas && options.spec.pod.replicas <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive integer for `replicas` in order to create an index.');
        }
        if (options.spec.pod.pods && options.spec.pod.pods <= 0) {
            throw new errors_1.PineconeArgumentError('You must pass a positive integer for `pods` in order to create an index.');
        }
        if (!types_1.ValidPodTypes.includes(options.spec.pod.podType)) {
            throw new errors_1.PineconeArgumentError(`Invalid pod type: ${options.spec.pod.podType}. Valid values are: ${types_1.ValidPodTypes.join(', ')}.`);
        }
    }
    else if (options.spec.byoc) {
        // Validate that environment is passed
        if (!options.spec.byoc.environment) {
            throw new errors_1.PineconeArgumentError('You must pass an `environment` for the `CreateIndexByocSpec` object to create an index.');
        }
    }
};
const validateReadCapacity = (readCapacity) => {
    if (!readCapacity)
        return; // default to OnDemand
    // Validate mode if provided
    const mode = readCapacity.mode;
    if (mode &&
        mode.toLowerCase() !== 'ondemand' &&
        mode.toLowerCase() !== 'dedicated') {
        throw new errors_1.PineconeArgumentError(`Invalid read capacity mode: ${mode}. Valid values are: 'OnDemand' or 'Dedicated'.`);
    }
    if (!(0, exports.isDedicated)(readCapacity)) {
        // OnDemand mode: no dedicated fields provided
        return;
    }
    // Dedicated mode
    const { nodeType, manual } = readCapacity;
    if (!nodeType || !['b1', 't1'].includes(nodeType)) {
        throw new errors_1.PineconeArgumentError(`Invalid node type: ${nodeType}. Valid values are: 'b1' or 't1'.`);
    }
    if (!manual) {
        throw new errors_1.PineconeArgumentError('CreateIndexReadCapacity.manual is required for dedicated mode.');
    }
    const { replicas, shards } = manual;
    if (!Number.isInteger(replicas) || replicas < 0) {
        throw new errors_1.PineconeArgumentError('CreateIndexReadCapacity.manual.replicas must be 0 or a positive integer.');
    }
    if (!Number.isInteger(shards) || shards <= 0) {
        throw new errors_1.PineconeArgumentError('CreateIndexReadCapacity.manual.shards must be a positive integer.');
    }
};
exports.validateReadCapacity = validateReadCapacity;
const isDedicated = (rc) => !!rc &&
    typeof rc === 'object' &&
    (rc.mode?.toLowerCase() === 'dedicated' ||
        'nodeType' in rc ||
        'manual' in rc);
exports.isDedicated = isDedicated;
const toApiReadCapacity = (rc) => {
    if (!rc)
        return undefined;
    if (!(0, exports.isDedicated)(rc)) {
        return { mode: 'OnDemand' };
    }
    const { nodeType, manual } = rc;
    return {
        mode: 'Dedicated',
        dedicated: {
            nodeType,
            scaling: 'Manual',
            manual: {
                replicas: manual.replicas,
                shards: manual.shards,
            },
        },
    };
};
exports.toApiReadCapacity = toApiReadCapacity;
//# sourceMappingURL=createIndex.js.map