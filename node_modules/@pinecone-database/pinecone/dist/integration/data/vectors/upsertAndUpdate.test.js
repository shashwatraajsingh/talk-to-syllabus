"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../../index");
const test_helpers_1 = require("../../test-helpers");
let pinecone;
let srvrlssIndexDense;
let srvrlssIndexDenseName;
let srvrlssIndexSparse;
let srvrlssIndexSparseName;
let denseRecordIds;
let sparseRecordIds;
let denseMetadata;
let sparseMetadata;
// upserts against two indexes (dense & sparse) and seeds them with test data
beforeAll(async () => {
    pinecone = new index_1.Pinecone();
    srvrlssIndexDenseName = (0, test_helpers_1.randomName)('test-srvrlss-dense-upsert-update');
    srvrlssIndexSparseName = (0, test_helpers_1.randomName)('test-srvrlss-sparse-upsert-update');
    const densePromise = pinecone.createIndex({
        name: srvrlssIndexDenseName,
        dimension: 2,
        metric: 'cosine',
        spec: {
            serverless: {
                region: 'us-east-1',
                cloud: 'aws',
            },
        },
        vectorType: 'dense',
        waitUntilReady: true,
        suppressConflicts: true,
    });
    const sparsePromise = pinecone.createIndex({
        name: srvrlssIndexSparseName,
        metric: 'dotproduct',
        spec: {
            serverless: {
                region: 'us-east-1',
                cloud: 'aws',
            },
        },
        vectorType: 'sparse',
        waitUntilReady: true,
        suppressConflicts: true,
    });
    await Promise.all([densePromise, sparsePromise]);
    srvrlssIndexDense = pinecone.index({
        name: srvrlssIndexDenseName,
        namespace: test_helpers_1.globalNamespaceOne,
    });
    srvrlssIndexSparse = pinecone.index({
        name: srvrlssIndexSparseName,
        namespace: test_helpers_1.globalNamespaceOne,
    });
    // Seed indexes
    const sparseRecords = (0, test_helpers_1.generateRecords)({
        dimension: 2,
        quantity: 1,
        withSparseValues: true,
        withValues: false,
        withMetadata: true,
    });
    const denseRecords = (0, test_helpers_1.generateRecords)({
        dimension: 2,
        quantity: 1,
        withSparseValues: false,
        withMetadata: true,
    });
    denseMetadata = denseRecords[0].metadata || {};
    sparseMetadata = sparseRecords[0].metadata || {};
    // test upserts
    await Promise.all([
        srvrlssIndexSparse.upsert({ records: sparseRecords }),
        srvrlssIndexDense.upsert({ records: denseRecords }),
    ]);
    sparseRecordIds = sparseRecords.map((record) => record.id);
    denseRecordIds = denseRecords.map((record) => record.id);
    await Promise.all([
        (0, test_helpers_1.waitUntilRecordsReady)(srvrlssIndexSparse, test_helpers_1.globalNamespaceOne, sparseRecordIds),
        (0, test_helpers_1.waitUntilRecordsReady)(srvrlssIndexDense, test_helpers_1.globalNamespaceOne, denseRecordIds),
    ]);
});
afterAll(async () => {
    const deleteDense = pinecone.deleteIndex(srvrlssIndexDenseName);
    const deleteSparse = pinecone.deleteIndex(srvrlssIndexSparseName);
    await Promise.all([deleteDense, deleteSparse]);
});
describe('update', () => {
    describe('dense indexes', () => {
        test('verify update by id', async () => {
            const recordId = denseRecordIds[0];
            const newValues = [0.5, 0.4];
            const newMetadata = { flavor: 'chocolate' };
            await srvrlssIndexDense.update({
                id: recordId,
                values: newValues,
                metadata: newMetadata,
            });
            await (0, test_helpers_1.assertWithRetries)(() => srvrlssIndexDense.fetch({ ids: [recordId] }), (result) => {
                expect(result.records[recordId]).toBeDefined();
                expect(result.records[recordId].values).toEqual(newValues);
                expect(result.records[recordId].metadata).toMatchObject(newMetadata);
            });
        });
        test('verify update by metadata (filter)', async () => {
            const metadataKey = Object.keys(denseMetadata)[0];
            const metadataValue = denseMetadata[metadataKey];
            const newMetadata = { flavor: 'vanilla' };
            await srvrlssIndexDense.update({
                filter: { [metadataKey]: { $eq: metadataValue } },
                metadata: newMetadata,
            });
            await (0, test_helpers_1.assertWithRetries)(() => srvrlssIndexDense.fetchByMetadata({
                filter: { [metadataKey]: { $eq: metadataValue } },
            }), (result) => {
                const record = Object.values(result.records)[0];
                expect(record).toBeDefined();
                expect(record.metadata).toMatchObject(newMetadata);
            });
        });
    });
    describe('sparse indexes', () => {
        test('verify update by id', async () => {
            const recordId = sparseRecordIds[0];
            const newSparseValues = [0.5, 0.4];
            const newSparseIndices = [0, 1];
            const sparseValues = {
                values: newSparseValues,
                indices: newSparseIndices,
            };
            const newMetadata = { flavor: 'chocolate' };
            await srvrlssIndexSparse.update({
                id: recordId,
                sparseValues: sparseValues,
                metadata: newMetadata,
            });
            await (0, test_helpers_1.assertWithRetries)(() => srvrlssIndexSparse.fetch({ ids: [recordId] }), (result) => {
                expect(result.records[recordId]).toBeDefined();
                expect(result.records[recordId].sparseValues).toEqual(sparseValues);
                expect(result.records[recordId].metadata).toMatchObject(newMetadata);
            });
        });
        test('verify update by metadata (filter)', async () => {
            const metadataKey = Object.keys(sparseMetadata)[0];
            const metadataValue = sparseMetadata[metadataKey];
            const newMetadata = { flavor: 'vanilla' };
            await srvrlssIndexSparse.update({
                filter: { [metadataKey]: { $eq: metadataValue } },
                metadata: newMetadata,
            });
            await (0, test_helpers_1.assertWithRetries)(() => srvrlssIndexSparse.fetchByMetadata({
                filter: { [metadataKey]: { $eq: metadataValue } },
            }), (result) => {
                const record = Object.values(result.records)[0];
                expect(record).toBeDefined();
                expect(record.metadata).toMatchObject(newMetadata);
            });
        });
    });
});
//# sourceMappingURL=upsertAndUpdate.test.js.map