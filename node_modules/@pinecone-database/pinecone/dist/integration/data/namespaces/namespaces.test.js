"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("../../test-helpers");
const test_context_1 = require("../../test-context");
const namespaceOne = (0, test_helpers_1.randomName)('namespace-one');
const namespaceTwo = (0, test_helpers_1.randomName)('namespace-two');
const namespaceThree = (0, test_helpers_1.randomName)('namespace-three');
let pinecone, serverlessIndexName;
describe('namespaces operations', () => {
    beforeAll(async () => {
        const fixtures = await (0, test_context_1.getTestContext)();
        pinecone = fixtures.client;
        serverlessIndexName = fixtures.serverlessIndex.name;
        const serverlessIndexNsOne = pinecone.index({
            name: serverlessIndexName,
            namespace: namespaceOne,
        });
        const serverlessIndexNsTwo = pinecone.index({
            name: serverlessIndexName,
            namespace: namespaceTwo,
        });
        // Seed indexes
        const recordsToUpsert = (0, test_helpers_1.generateRecords)({ dimension: 2, quantity: 5 });
        await serverlessIndexNsOne.upsert({ records: recordsToUpsert });
        await serverlessIndexNsTwo.upsert({ records: recordsToUpsert });
        await (0, test_helpers_1.sleep)(2000); // Wait for the upsert operations to complete
    });
    // Tests deleteNamespace
    afterAll(async () => {
        await pinecone
            .index({ name: serverlessIndexName })
            .deleteNamespace(namespaceThree);
        await (0, test_helpers_1.assertWithRetries)(() => pinecone.index({ name: serverlessIndexName }).listNamespaces(), (response) => {
            expect(response.namespaces).toEqual(expect.arrayContaining([
                expect.objectContaining({ name: namespaceOne }),
            ]));
            expect(response.namespaces).toEqual(expect.arrayContaining([
                expect.objectContaining({ name: namespaceTwo }),
            ]));
            expect(response.namespaces).not.toEqual(expect.arrayContaining([
                expect.objectContaining({ name: namespaceThree }),
            ]));
        }, 240000);
    });
    test('create namespace', async () => {
        const response = await pinecone
            .index({ name: serverlessIndexName })
            .createNamespace({
            name: namespaceThree,
            schema: { fields: { test: { filterable: true } } },
        });
        expect(response.name).toEqual(namespaceThree);
        expect(response.schema?.fields.test.filterable).toBe(true);
    });
    test('list namespaces', async () => {
        const response = await pinecone
            .index({ name: serverlessIndexName })
            .listNamespaces();
        expect(response.namespaces).toEqual(expect.arrayContaining([
            expect.objectContaining({ name: namespaceOne }),
            expect.objectContaining({ name: namespaceTwo }),
        ]));
    });
    test('describe namespace', async () => {
        let response = await pinecone
            .index({ name: serverlessIndexName })
            .describeNamespace(namespaceOne);
        expect(response.name).toEqual(namespaceOne);
        response = await pinecone
            .index({ name: serverlessIndexName })
            .describeNamespace(namespaceTwo);
        expect(response.name).toEqual(namespaceTwo);
    });
});
//# sourceMappingURL=namespaces.test.js.map